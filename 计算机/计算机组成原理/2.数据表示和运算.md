[TOC]

### 位运算

```c++
// 异或、模2减、模2加 (两数相应位不同，结果为 1)
0^0 = 0
0^1 = 1
1^0 = 1
1^1 = 0    
```





### 进位计数法

m进制，m是基数，$m^i$ 是第 $i$ 位的位权：

* 用十进制表示 125.72 ，即 m=10

$$
1*10^2 + 2*10^1 + 5*10^0 + 7*10^{-1} + 2*10^{-2} = 125.72
$$

* 任意进制转十进制

$$
\begin{align*}

& 二进制数：1001.11  \\
& m为2，转化为十进制：1*2^3 + 0*2^2 + 0*2^1 + 1*2^0 + 1*2^{-1} + 1*2^{-2} = 9.75\\

\end{align*}
$$

* 十进制转任意进制

    整数部分使用除基取余法，小数部分使用乘基取整法。常考的十进制转二进制，一般使用拼凑法。

    对于十进制转八或十六进制，可以使用拼凑法转为二进制，再转为八、十六进制。



* 二进制转八进制，三位一组，前后不足就补 0，称之为补位

$$
二进制数：001 111 000 010 . 011 010 \\
转八进制：\underbrace{001}_{1} \underbrace{111}_{7} \underbrace{000}_{0} \underbrace{010}_{2} \underbrace{.}_{.} \underbrace{011}_{3} \underbrace{010}_{2} \Rightarrow 1702.32
$$

* 八进制转二进制

$$
八进制数：(251.5)_{8} \\
转二进制：\underbrace{2}_{010} \underbrace{5}_{101} \underbrace{1}_{001} \underbrace{.}_{.} \underbrace{5}_{101} \Rightarrow 010101001.101
$$

* 二进制转十六进制，四位一组，前后不足补 0，称之为补位

$$
二进制数：0011 1100 0010 . 0110 1000 \\
转八进制：\underbrace{0011}_{3} \underbrace{1100}_{C} \underbrace{0010}_{2} \underbrace{.}_{.} \underbrace{0110}_{6} \underbrace{1000}_{8} \Rightarrow 3C2.68
$$

* 十六进制转二进制

$$
十六进制：(AE86.1)_{16} \\
转二进制：\underbrace{A}_{1010} \underbrace{E}_{1110} \underbrace{8}_{1000} \underbrace{6}_{0110} \underbrace{.}_{.} \underbrace{1}_{0001} \Rightarrow 1010111010000110.0001
$$



### BCD码

**B**inary-**C**oded **D**ecimal，将每4位二进制位，转为一个十进制位。

* 8421码，4个二进制位的权值分别是8421。如 十进制数 985 用 8421码表示：1001 1000 0101。如果两数相加，结果落在非法区间就 +6，如 0101 + 1000 = 1101，1101 + 0110 = 0001 1011，即十进制的 13
* 2421码，同样4个二进制位对应一个十进制为，每位权值是2421，如二进制 0011 就是 3。因为 0101、1011都可以表示 5，所以规定 [5,9] 的最高位用1表示。
* 余3码是 8421码 + 0011，所以与8421相比，余3码每一位没有固定的权值，故称为无权码。





### 定点数的表示

小数点位置固定称为定点数。分为无符号数和有符号数。有符号数可用原码、反码、补码、移码表示。

**无符号数** 表示整个机器字长的全部二进制位均为数值位，没有符号位，相当于绝对值。一般只表示整数。
$$
1001 1100B \\
1*2^7 + 0*2^6 + 0*2^5 + 1*2^4 + 1*2^3 + 1*2^2 + 0*2^1 + 0*2^0 = 156D
$$

| 2^16  | 2^15  | 2^14  | 2^13 | 2^12 | 2^11 |
| ----- | ----- | ----- | ---- | ---- | ---- |
| 65536 | 32768 | 16384 | 8192 | 4096 | 2048 |

**有符号数的定点表示** 通常0为正，1为负。
$$
定点整数：\underbrace{x_0}_{符号位} \underbrace{x_0x_1x_2x_4..x_n}_{数值部分} \underbrace{.}_{小数点位置(隐含)} \\

定点小数：\underbrace{x_0}_{符号位} \underbrace{.}_{小数点位置(隐含)} \underbrace{x_0x_1x_2x_4..x_n}_{数值部分 (尾数)}
$$


**原码** ，表示整数时，若有 n 位数值位，1 位符号位，则机器字长为 n+1 位，表示范围：

$-(2^n-1) \leq x \leq 2^n-1$，有两种 0 的表示方式，即 +0(0000 000) 和 -0(1000 0000)。

表示小数时，若有 n 位数值位，1 位符号位，则机器字长为 n+1 位，表示范围：

$-(1-2^{-n}) \leq x \leq 1-2^{-n}$，真值 0 同样有两种表示方式。

​	定点整数：$[+19D]_原 = 0001 \ 0011$ ，定点小数：$[+0.75D]_原 = 0110 \ 0000$

​	定点整数：$[-19D]_原 = 1001 \ 0011$ ，定点小数：$[-0.75D]_原 = 1110 \ 0000$ （常写为 1.11）



**反码** ，若符号位为 0，反码与原码相同。若符号位为 1，数值位全部取反。0 同样有两种表示方式，范围同原码。

​	定点整数：$[+19D]_原 = 0001 \ 0011$ ，定点小数：$[+0.75D]_原 = 0110 \ 0000$

​	定点整数：$[+19D]_反 = 0001 \ 0011$ ，定点小数：$[+0.75D]_反 = 0110 \ 0000$  （全部不变）

​	定点整数：$[-19D]_原 = 1001 \ 0011$ ，定点小数：$[-0.75D]_原 = 1110 \ 0000$

​	定点整数：$[-19D]_反 = 1110 \ 1100$ ，定点小数：$[-0.75D]_反 = 1001 \ 1111$  （全部取反）



**补码** ，正数的补码就是原码，负数的补码 = 反码末位 + 1。负数的补码求原码：尾数取反，末位 +1

表示整数时，0 只有一种表示方式。因此多出来的状态：$[x]_补 = 1000 \ 0000$ 表示 $x=-2^7$，若机器字长 n+1 位，则表示范围：$-2^n \leq x \leq 2^n-1$

表示小数时，0 只有一种表示方式。因此多出来的状态：$[x]_补 = 1000 \ 0000$ 表示 $x=-1$，若机器字长 n+1 位，则表示范围：$-1 \leq x \leq 1-2^{-n}$ 

​	定点整数：$[+19D]_原 = 0001 \ 0011$ ，定点小数：$[+0.75D]_原 = 0110 \ 0000$

​	定点整数：$[+19D]_反 = 0001 \ 0011$ ，定点小数：$[+0.75D]_反 = 0110 \ 0000$  

​	定点整数：$[+19D]_补 = 0001 \ 0011$ ，定点小数：$[+0.75D]_补 = 0110 \ 0000$ （不变）

​	定点整数：$[-19D]_原 = 1001 \ 0011$ ，定点小数：$[-0.75D]_原 = 1110 \ 0000$

​	定点整数：$[-19D]_反 = 1110 \ 1100$ ，定点小数：$[-0.75D]_反 = 1001 \ 1111$  

​	定点整数：$[-19D]_补 = 1110 \ 1101$ ，定点小数：$[-0.75D]_补 = 1010 \ 0000$  （反码末位 +1）



**移码** ，将补码的符号位取反，只用于表示整数。0 (10000000)只有一种表示形式，整数表示范围同补码相同。

​	定点整数：$[+19D]_原 = 0001 \ 0011$ ，定点整数：$[-19D]_原 = 1001 \ 0011$ 

​	定点整数：$[+19D]_反 = 0001 \ 0011$ ，定点整数：$[-19D]_反 = 1110 \ 1100$ 

​	定点整数：$[+19D]_补 = 0001 \ 0011$ ，定点整数：$ [-19D]_补 = 1110 \ 1101 $ 

​	定点整数：$[+19D]_移 = 1001 \ 0011$ ，定点整数：$[-19D]_移 = 0110 \ 1101$ 





### 知错（奇偶校验码）

若干位代码组成的字称为码字。一种编码方案的检错能力如何和他的码距息息相关，码距就是合法码字之间不同位的个数。码距是1就没有检错能力，为2时有检错能力，大于等于3时，可能有检错、纠错能力。奇偶校验码是最简单的错误检测码。

奇校验码即包含有效信息位和校验位的整个字节中，1 的个数是奇数。偶校验码同理。可在低位（右）或高位（左）添加校验位。当错误的位数是偶数时，那就检测不出了。

| 有效信息位 | 奇校验码      | 偶校验码      |
| ---------- | ------------- | ------------- |
| 1010 111   | 1010 111**0** | 1010 111**1** |
| 1001 101   | 1001 101**1** | 1001 101**0** |

在机器中求偶校验位，就是对所有位使用异或计算 `1^0^0^1^1^0^1 = 0`、`1^0^1^0^1^1^1 = 1`

在机器进行偶校验，对所有位进行异或，结果为 1，说明出错。`1^0^0^1^1^0^1^0 = 0`



### 能改（海明码）

海明校验码中 n个信息位，k个校验位。能表示 $2^k$ 个状态，这些状态应包含 n+k 位出错的情况和一个正确的情况。因此 
$$
2^k \geq n+k+1
$$

| n    | 1    | 2-4  | 5-11 | 12-26 | 27-57 | 58-120 |
| ---- | ---- | ---- | ---- | ----- | ----- | ------ |
| k    | 2    | 3    | 4    | 5     | 6     | 7      |

假设信息位用 $D_i$ 表示，校验位用 $P_i$ 表示。对应的海明码用 $H_i$ 表示。与奇偶校验码不同，海明码的校验码不是集中在头或尾。而是分散在 $2^{i-1}$ 的位置上。即 $P_1P_2P_3$ 应该在 $H_1H_2H_4$ 上。其实就是 1 2 4 8 16...

| H7   | H6   | H5   | H4   | H3   | H2   | H1   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| D4   | D3   | D2   | P3   | D1   | P2   | P1   |
| 1    | 0    | 1    |      | 0    |      |      |

如何确定 $P_i$ 的值？已知 $D_1D_2D_3D_4$ 在 $H_3H_5H_6H_7$ 中，因此将 3 5 6 7 转为二进制

```
H3：3 => 011
H5: 5 => 101
H6: 6 => 110
H7: 7 => 111
```

竖着看：

最低位为 1 的归为 $P_1$ ，即 $H_3H_5H_7$ 归 $P_1$ 组，就是将 $D_1D_2D_4$ 中内容的偶校验码 `0^1^1 = 0` 赋值给 $P_1$ 。

中间位为 1 的归为 $P_2$ ，即 $H_3H_6H_7$ 归 $P_2$ 组，就是将 $D_1D_3D_4$ 中内容的偶校验码 `0^0^1 = 1` 赋值给 $P_2$ 。

最高位为 1 的归为 $P_3$ ，即 $H_5H_6H_7$ 归 $P_3$ 组，就是将 $D_2D_3D_4$ 中内容的偶校验码 `1^0^1 = 0` 赋值给 $P_3$ 。

得：

| H7   | H6   | H5   | H4    | H3   | H2    | H1    |
| ---- | ---- | ---- | ----- | ---- | ----- | ----- |
| D4   | D3   | D2   | P3    | D1   | P2    | P1    |
| 1    | 0    | 1    | **0** | 0    | **1** | **0** |

如何检错、纠错呢？就是将各个分组的二进制位进行异或（偶校验），如果无措，结果应为 0.

```
若接收到的是：1010010
S1 = P1^D1^D2^D4 = 0^0^1^1 = 0 
S2 = P2^D1^D3^D4 = 1^0^0^1 = 0
S3 = P3^D2^D3^D4 = 0^1^0^1 = 0

若接收到的是：1010000  // p2 跳变，从 1 变为 0
S1 = P1^D1^D2^D4 = 0^0^1^1 = 0 
S2 = P2^D1^D3^D4 = 0^0^0^1 = 1
S3 = P3^D2^D3^D4 = 0^1^0^1 = 0

从 S1 到 S3 表示低位到高位，结果是 010 就是十进制的 2，表示 H2 错误
```

可是如果不止一个位置错了呢？海明码有一个位的纠错能力，两个位的检错能力。

因此日常中，会再加上一个全校验位。即对整体进行偶校验。包含以下几个情况：
$$
\begin{align*}
S_1S_2S_3 &= 000 \ 且 \ 全体偶校验成功 \Rightarrow 无错误 \\
S_1S_2S_3 &\neq 000 \ 且 \ 全体偶校验失败 \Rightarrow 有一位错误，纠正即可 \\
S_1S_2S_3 &\neq 000 \ 且 \ 全体偶校验成功 \Rightarrow 有两位错误，需重传
\end{align*}
$$


### 能改（循环冗余校验码）

**Cyclic redundancy check**，通称 “**CRC**”。

首先K为信息码的长度，设生成多项式 $G(x)=x^3+x^2+1$ ，则对应的二进制码（除数）为 1101，因为 $G(x)=1x^3+1x^2+0x^1+1x^0$，R是多项式的最高次幂，R的位数是除数的位数减一位。K个信息位加R个0作为被除数。

进行模2除，得R位余数。至此得 `CRC码 = K位信息位 + R位余数 `。

接收端收到 K+R 位数据，与生成多项式即刚才的除数进行模二除，若余数为 0，表明无错，非0即有错。

虽然在 $2^R \geq K+R+1 $ 时具有一位的纠错能力，但实际只用于检错。