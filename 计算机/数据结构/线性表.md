[TOC]



## 顺序表

### 顺序存储

```c++
// 静态分配

#include <stdio.h>
#define MaxSize 10
typedef struct {
    int data[MaxSize];
    int length;
}SqList;

void InitList(SqList &L) {
    for (int i = 0; i < MaxSize; i++) {
        L.data[i] = 0;
    }
    L.length = 0;
}

int main() {
    SqList L;
    InitList(L);
    for (int i = 0; i < L.length; i++) 
        printf("data[%d]=%d\n", i, L.data[i]);
	return 0;
}
```



```c++
// 动态分配

#include <stdlib.h>
#define InitSize 10
typedef struct {
    int *data;
    int MaxSize;
    int length;
}SeqList;

void InitList(SeqList &L) {
    L.data = (int *) malloc(InitSize * sizeof(int));
    L.length = 0;
    L.MaxSize = InitSize;
}

void IncreaseSize(SeqList &L, int len) {
    int *p = L.data;
    L.data = (int *) malloc((L.MaxSize + len) * sizeof(int));
    for (int i = 0; i < L.length; i++) {
        L.data[i] = p[i];			// 将数据表复制到新区域
    }
    L.MaxSize = L.MaxSize + len;	// 数据表最大长度增加 len
    free(p);						// 释放原表的内存
}

int main() {
    SeqList L;
    InitList(L);
    IncreaseSize(L, 5);
    return 0;
}
```



### 增

```c++
// 在第 i 个位置上, 插入 e
// 最好 O(1), 最坏 O(n), 平均 O(n/2) => O(n)
bool ListInsert(SqList &L, int i, int e) {
    if (i < 1 || i > L.length + 1) return false;
    if (L.length >= L.MaxSize) return false;
    for (int j = L.length; j >= i; j--) {
        L.data[j] = L.data[j - 1];
    }
    L.data[i-1] = e;
    L.length ++;
    return true;
}
```



### 删

```c++
// 删除第 i 个元素
// O(n)
bool ListDelete(SqList &L, int i, int &e) {
    if (i < 1 || i > L.length) return false;
    e = L.data[i - 1];
    for (int j = i; j < L.length; j++) {
        L.data[j - 1] = L.data[j];
    }
    L.length --;
    return true;
}
```



### 查

```c++
// 按位查找, 获取第 i 个元素, 
// O(1)
E GetElem(SqList L, int i) {
    return L.data[i - 1];
}

// 按值查找, 返回位序
// 最好 O(1)； 最坏 O(n)； 平均 O(n)
int locateElem(SqList L, E e) {
    for (int i = 0; i < L.length; i++) {
        if (L.data[i] == e) {
            return  i + 1;
        }
    }
    return -1;
}

```





## 单链表

### 定义

```c++
struct LNode {
    E data;
    struct LNode *next;
}

struct LNode * p = (struct LNode *) malloc(sizeof(struct LNode));
```

```c++
// 不带头结点
typedef struct LNode {
    E data;
    struct LNode *next;
}LNode, *LinkList;

bool InitList(LinkList &L) {
    L = null;
    return true;
}

bool empty(LinkList L) {
    return (L == NULL);
}


// 带头结点
typedef struct LNode {
    E data;
    struct LNode *next;
}LNode, *LinkList;

bool InitList(LinkList &L) {
    L = (LNode *) malloc(sizeof(LNode));
    if (L == NULL)
        return false;
    L->next = NULL;
    return true;
}

bool empty(LinkList L) {
    return (L->next == NULL);
}
```



### 插入

```c++
// 带头结点, 在第 i 个位置, 插入元素 e
// 头结点不算, 之后从 1 开始数
// O(n)
bool ListInsert(LinkList &L, int i, E e) {
    if (i < 1) return false;
    LNode *p;		// 指向当前扫描到的结点
    int j = 0;		// 指向第 j 个结点
    p = L;			// L 指向头节点, 头结点是第 0 个结点, 不存数据
    while (p != NULL && j < i-1) {	// 循环到第 i-1 个结点
        p = p->next;
        j ++;
    }
    if (p == NULL) return false;
	LNode *s = (LNode *)malloc(sizeof(LNode));
    if (s == NULL) return false; 	// 内存分配失败
    s->data = e;
    s->next = p->next;
    p->next = s;
    return true;
}

// 不带头结点, 在第 i 个位置, 插入元素 e
// O(n)
bool ListInsert(LinkList &L, int i, E e) {
    if (i < 1) return false;
    if (i == 1) {	// 结点插入到第一个位置需要特判
        LNode *s = (LNode *) malloc(sizeof(LNode));
        s->data = e;
        s->next = L;
        L = s;
        return true;
    }
    LNode *p;
    int j = 1;		// 因为没有头结点, 所以从一开始
    p = L;
    while (p != NULL && j < i - 1) {
        p = p->next;
        j++;
    }
    if (p == NULL) return false;
    LNode *s = (LNode *) malloc(sizeof(LNode));
    if (s == NULL) return false; 	// 内存分配失败
    s->data = e;
    s->next = p->next;
    p-next = s;
    return true;
}
```

```c++
/**
*	前插操作, 在 p 结点之前插入元素 e
*	实际是在 p 结点之后插入一个结点 s
*	变为：p->s->k->...
*	再将 p 的值放进 s, e 的值放入 p
*	O(1)
*/
bool InsertPriorNode(LNode *p, E e) {
    if (p == NULL) return false;
    LNode *s = (LNode *)malloc(sizeof(LNode));
    if (s == NULL) return false;
    s->next = p->next;
    p->next = s;
    s->data = p->data;
    p->data = e;
    return true;
}

// 链表同样为：p->s->k->... 只是交换了值
bool InsertPriorNode(LNode *p, LNode *s) {
    if (p == NULL || s == NULL) return false;
    s->next = p->next;
    p->next = s;
    E temp = p->data;
    p->data = s->data;
    s->data = temp;
    return true;
}
```



### 删除

```c++
// 带头结点, 按位序删除
// 头结点算第 0 个结点
// O(n)
bool ListDelete(LinkList &L, int i, E e) {
    if (i < 1) return false;
    LNode *p;
    int j = 0;
    p = L;
    while (p != NULL && j < i - 1) {	// 循环到 i-1 个结点, 就是待删除的前一个结点
        p = p->next;
        j ++;
    }
    if (p == NULL) return false;
    if (p -> next == NULL) return false;
    LNode *q = p->next;					// q 指向待被删除的结点
    e = q->data;
    p->next = q->next;
    free(q);
    return true;
}

/** 
*	删除结点 p
* 	链表：p->q->k->...
* 	其实是将 p 的后一个元素的值放到 p 上
* 	再删除 p 的后一个元素
*/
bool DeleteNode(LNode *p) {
    if (p == NULL) return false;
    LNode *q = p->next;
    p->data = p->next->data;
    p->next = q->next;
    free(q);
    return true;
}
```



### 查找

```c++
// 带头结点, 按位查找第 i 个元素
// 把头结点当作第 0 个结点
// O(n)
LNode * GetElem(LinkList L, int i) {
    if (i < 0) return NULL;
    LNode *p;
    int j = 0;
    p = L;
    while (p != NULL && j < i) {
        p = p->next;
        j ++;
    }
    return p;
}


// 按值查找
// O(n)
LNode * LocateElem(LinkList L, E e) {
    LNode *p = L->next;
    // 注意 e 的类型, 某些类型不能直接使用 '!=' 进行判断
    while (p != NULL && p->data != e) {
        p = p->next;
    }
    return p;
}
```



### 头插

```c++
// 头插
LinkList List_Headinsert(LinkList &L) {
    LNode *s;
    int x;
    L = (LinkList)malloc(sizeof(LNode));
    L->next = NULL;
    scanf("%d", &x);
    while (x != 9999) {
        s = (LNode*) malloc(sizeof(LNode));
        s->data = x;
        s->next = L->next;
        L->next = s;
        scanf("%d", &x);
    }
    return L;
}
```





## 双链表

```c++
// 带头结点
typedef struct DNode {
    E data;						// 数据域
    struct DNode *prior, *next;	// 前驱、后继指针
}DNode, *DLinkList;

bool InitDLinkList(DLinkList &L) {
    L = (DNode *) malloc(sizeof(DNode));
    if (L == NULL) return false;
    L->prior = NULL;
    L->next = NULL;
    return true;
}

// 在 p 结点之后插入 s
bool InsertNextDNode(DNode *p, DNode *s) {
    if (p == NULL || s == NULL)	return false;
    s->next = p->next;
    if (p->next != NULL) 
        p->next->prior = s;
    s->prior = p;
    p->next = s;
    return true;
}

// 删除 p 结点的后一个
bool DeleteNextDNode(DNode *p) {
    if (p == NULL) return false;
    DNode *q = p->next;
    if (q == NULL) return false;
    p->next = q->next;
    if (q->next != NULL) 
        q->next->prior = p;
    free(q);
    return true;
}

int main() {
    DLinkList L;
    InitDLinkList(L);
    return 0;
}
```





## 循环链表

```c++
// 循环单链表
typedef struct LNode {
    E data;
    struct LNode *next;
}LNode, *LinkList;

bool InitList(LinkList &L) {
    L = (LNode *) malloc(sizeof(LNode));
    if (L == NULL) return false;
    L->next = L;	// 头结点的 next 指向自己
    return true;
}

bool empty(LinkList L) {
    return L->next == L;
}

bool isTail(LinkList L, LNode *p) {
    return p->next == L;
}
```

```c++
// 循环双链表
typedef struct DNode {
    E data;
    struct DNode *prior, *next;
}DNode, *DLinkList;

bool InitDLinkList(DLinkList &L) {
    L = (DNode *) malloc(sizeof(DNode));
    if (L == NULL) return false;
    L->prior = L;	// 头结点的 前驱指针 指向自己
    L->next = L;	// 头结点的 后继指针 指向自己
    return true;
}

bool empty(DLinkList L) {
    return L->next == L;
}

bool isTail(DLinkList L, DNode *p) {
    return p->next == L;
}
```



