[TOC]



```c++
// 静态数组实现（定长顺序存储）
#define MAXLEN 255
typedef struct {
    char ch[MAXLEN];
    int length;
}SString;

// 动态数组实现（堆分配存储）
typedef struct {
    char *ch;
    int length;
}HString;
HString s;
S.ch = (char *) malloc(MAXLEN * sizeof(char));
S.length = 0;
```



```c++
// 密度太低 因为实际信息 1B, 而辅助信息 4B
typedef struct StringNode {
    char ch;					// 1B
    string StringNode * next;	// 4B
}StringNode, * String;

// 存储密度高
typedef struct StringNode {
    char ch[4];
    struct StringNode * next;
}StringNode, * String;
```



### 基本操作

```c++
// 数组的 0下标 不存数据, 从 下标1 开始, 再加 length 存长度

// 截取 S 中从 pos 开始向后 len 位 , 通过 Sub 返回
bool subString(SString &Sub, SString S, int pos, int len) {
    if (pos + len - 1 > S.length)	return false;
    for (int i = pos; i < pos + len; i++) {
        Sub.ch[i - pos + 1] = S.ch[i];
    }
    Sub.length = len;
    return true;
}

// 比较
int strCompare(SString S, SString t) {
    for (int i = 1; i <= S.length && i <= T.length; i++) {
        if (S.ch[i] != T.ch[i]) return S.ch[i] - T.ch[i];
    }
    // 短的被扫完，对比长度
    return S.length - T.length;
}
```



### 模式匹配 - 朴素模式匹配

```c++
// T串 在 S串中的位置 , 最多匹配 n-m+1 次
int index(SString S, SString T) {
    int i = 1, n = S.length, m = T.length;
    SString sub;
    while (i <= n-m+1) {	// 截取 S 中与 T 相同长度的串, 进行对比 
       	subString(sub, S, i, m);			
        if (strCompare(sub, T) != 0) ++i;	
        else return i;
    }
    return 0;
}
```

```c++
// 使用 双指针 实现
// 最坏 O(mn)
int index(SString S, SString T) {
    int i = 1, j = 1;
    while (i <= S.length && j <= T.length) {
        if (S.ch[i] == T.ch[j]) {	// 若匹配 则两个指针均向后移
            ++i, ++j;
        } else {
            i = i - j + 2;			// 不匹配 i 回到下一组开头位置进行匹配
            j = 1;
        }
    }
    if (j > T.length) return i - T.length;	// 完全匹配 此时 j 都爆表啦!!!
    else return 0;
}
```



### 模式匹配 - KMP

```c++
// https://www.bilibili.com/video/BV1PD4y1o7nd
int index_KMP(SString S, SString T, int next[]) {
    int i = 1, j = 1;
    while (i <= S.length && j <= T.length) {
        if (j == 0 || S.ch[i] == T.ch[i]) {			// 继续比较后继字符
            ++i, ++j;
        } else {
            j = next[j];							// j 回到事先处理好的 next 标注的位置
        }
    }
    if (j > T.length) 
        return i - T.length;
    else 
        return 0;
}
```

```c++
// next 优化成 nextval
nextval[1] = 0;
for (int j = 2; j <= T.length; j++) {
    if (T.ch[next[j]] == T.ch[j]) 
        nextval[j] = nextval[next[j]];
    else 
        nextval[j] = next[j];
}
```

